<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>finlab_crypto.utility API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>finlab_crypto.utility</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from IPython.display import display, HTML, IFrame, clear_output
from itertools import compress, product
from collections.abc import Iterable
import matplotlib.pyplot as plt
import tqdm.notebook as tqdm
import ipywidgets as widgets
import vectorbt as vbt
import seaborn as sns
import pandas as pd
import numpy as np
import copy
import os

from . import chart
from . import overfitting


def is_evalable(obj):
    try:
        eval(str(obj))
        return True
    except:
        return False

def remove_pd_object(d):
    ret = {}
    for n, v in d.items():
        if ((not isinstance(v, pd.Series) and not isinstance(v, pd.DataFrame) and not callable(v) and is_evalable(v))
            or isinstance(v, str)):
            ret[n] = v
    return ret

def enumerate_variables(variables):

    if not variables:
        return []

    enumeration_name = []
    enumeration_vars = []

    constant_d = {}

    for name, v in variables.items():
        if (isinstance(v, Iterable) and not isinstance(v, str)
            and not isinstance(v, pd.Series)
            and not isinstance(v, pd.DataFrame)):

            enumeration_name.append(name)
            enumeration_vars.append(v)
        else:
            constant_d[name] = v

    variable_enumerations = [dict(**dict(zip(enumeration_name, ps)), **constant_d)
                             for ps in list(product(*enumeration_vars))]

    return variable_enumerations



def enumerate_signal(ohlcv, strategy, variables, ):
    entries = {}
    exits = {}

    fig = {}

    iteration = tqdm.tqdm(variables) if len(variables) &gt; 1 else variables
    for v in iteration:
        strategy.set_parameters(v)
        results = strategy.func(ohlcv)

        v = remove_pd_object(v)

        entries[str(v)], exits[str(v)] = results[0], results[1]
        if len(results) &gt;= 3:
            fig = results[2]

    entries = pd.DataFrame(entries)
    exits = pd.DataFrame(exits)

    # setup columns
    param_names = list(eval(entries.columns[0]).keys())
    arrays = ([entries.columns.map(lambda s: eval(s)[p]) for p in param_names])
    tuples = list(zip(*arrays))
    if tuples:
        columns = pd.MultiIndex.from_tuples(tuples, names=param_names)
        exits.columns = columns
        entries.columns = columns
    return entries, exits, fig

def stop_early(ohlcv, entries, exits, stop_vars, enumeration=True):

    if not stop_vars:
        return entries, exits

    # check for stop_vars
    length = -1
    stop_vars_set = {&#39;sl_stop&#39;, &#39;ts_stop&#39;, &#39;tp_stop&#39;}
    for s, slist in stop_vars.items():
        if s not in stop_vars_set:
            raise Exception(f&#39;variable { s } is not one of the stop variables&#39;
                             &#39;: sl_stop, ts_stop, or tp_stop&#39;)
        if not isinstance(slist, Iterable):
            stop_vars[s] = [slist]

        if length == -1:
            length = len(stop_vars[s])

        if not enumeration and length != -1 and length != len(stop_vars[s]):
            raise Exception(f&#39;lengths of the variables are not align: &#39;
                    + str([len(stop_vars[s]) for s, slist in stop_vars.items()]))

    if enumeration:
        stop_vars = enumerate_variables(stop_vars)
        stop_vars = {key: [stop_vars[i][key] for i in range(len(stop_vars))] for key in stop_vars[0].keys()}

    sl_advstex = vbt.ADVSTEX.run(
        entries,
        ohlcv[&#39;open&#39;],
        ohlcv[&#39;high&#39;],
        ohlcv[&#39;low&#39;],
        ohlcv[&#39;close&#39;],
        stop_type=None,
        **stop_vars
    )

    stop_exits = sl_advstex.exits

    nrepeat = int(len(stop_exits.columns) / len(entries.columns))
    if isinstance(stop_exits, pd.DataFrame):
        exits = exits.vbt.tile(nrepeat)
        entries = entries.vbt.tile(nrepeat)

    stop_exits = stop_exits.vbt | exits.values
    entries.columns = stop_exits.columns

    return entries, stop_exits

def plot_strategy(ohlcv, entries, exits, portfolio ,fig_data, html=None):

    # format trade data
    txn = portfolio.positions().records
    txn[&#39;enter_time&#39;] = ohlcv.iloc[txn.entry_idx].index.values
    txn[&#39;exit_time&#39;] = ohlcv.iloc[txn.exit_idx].index.values

    # plot trade data
    mark_lines = []
    for name, t in txn.iterrows():
        x = [str(t.enter_time), str(t.exit_time)]
        y = [t.entry_price, t.exit_price]
        name = t.loc[[&#39;entry_price&#39;, &#39;exit_price&#39;, &#39;return&#39;]].to_string()
        mark_lines.append((name, x, y))

    # calculate overlap figures
    overlaps = {}
    if &#39;overlaps&#39; in fig_data:
        overlaps = fig_data[&#39;overlaps&#39;]

    # calculate sub-figures
    figures = {}
    if &#39;figures&#39; in fig_data:
        figures = fig_data[&#39;figures&#39;]

    figures[&#39;entries &amp; exits&#39;] = pd.DataFrame(
        {&#39;entries&#39;:entries.squeeze(), &#39;exits&#39;: exits.squeeze()})
    figures[&#39;performance&#39;] = portfolio.cumulative_returns()

    c, info = chart.chart(ohlcv, overlaps=overlaps,
                          figures=figures, markerlines=mark_lines,
                          start_date=ohlcv.index[-min(1000, len(ohlcv))], end_date=ohlcv.index[-1])
    c.load_javascript()
    if html is not None:          
        c.render(html)
    else:
        c.render()
        display(HTML(filename=&#39;render.html&#39;))

    return 

def plot_combination(portfolio, cscv_result=None, metric=&#39;final_value&#39;):

    sns.set()
    sns.set_style(&#34;whitegrid&#34;)

    fig, axes = plt.subplots(1, 2, figsize=(15, 4), sharey=False, sharex=False)
    fig.suptitle(&#39;Backtest Results&#39;)

    def heat_map(item, name1, name2, ax):
        if name1 != name2:
            sns.heatmap(item.reset_index().pivot(name1, name2)[0], cmap=&#39;magma_r&#39;, ax=ax)
        else:
            getattr(portfolio, item_name).groupby(name1).mean().plot(ax=ax)

    def best_n(portfolio, n):
        return getattr(portfolio, metric)().sort_values().tail(n).index

    best_10 = best_n(portfolio, 10)

    ax = (portfolio.cumulative_returns()[best_10] * 100).plot(ax=axes[0])
    ax.set(xlabel=&#39;time&#39;, ylabel=&#39;cumulative return (%)&#39;)

    axes[1].title.set_text(&#39;Drawdown (%)&#39;)
    for n, c in zip([5, 10, 20, 30], sns.color_palette(&#34;GnBu_d&#34;)):
        bests = best_n(portfolio, n)
        drawdown = portfolio.drawdown()[bests].min(axis=1)
        ax = drawdown.plot(linewidth=1, ax=axes[1])
        # ax.fill_between(drawdown.index, 0, drawdown * 100, alpha=0.2, color=c)
    ax.set(xlabel=&#39;time&#39;, ylabel=&#39;drawdown (%)&#39;)

    plt.show()


    items = [&#39;final_value&#39;, &#39;sharpe_ratio&#39;, &#39;sortino_ratio&#39;]
    fig, axes = plt.subplots(1, len(items), figsize=(15, 3),
                             sharey=False, sharex=False, constrained_layout=False)
    fig.subplots_adjust(top=0.75)
    fig.suptitle(&#39;Partial Differentiation&#39;)

    final_value = portfolio.final_value()
    if isinstance(final_value.index, pd.MultiIndex):
        index_names = final_value.index.names
    else:
        index_names = [final_value.index.name]

    for i, item in enumerate(items):
        results = {}
        for name in index_names:
            s = getattr(portfolio, item)()
            s = s.replace([np.inf, -np.inf], np.nan)
            results[name] = s.groupby(name).mean()
        results = pd.DataFrame(results)
        axes[i].title.set_text(item)
        results.plot(ax=axes[i])

    if cscv_result is None:
        return

    results = cscv_result

    fig, axes = plt.subplots(1, 3, figsize=(15, 5),
                             sharey=False, sharex=False, constrained_layout=False)
    fig.subplots_adjust(bottom=0.5)
    fig.suptitle(&#39;Combinatorially Symmetric Cross-validation&#39;)

    pbo_test = round(results[&#39;pbo_test&#39;] * 100, 2)
    axes[0].title.set_text(f&#39;Probability of overfitting: {pbo_test} %&#39;)
    axes[0].hist(x=[l for l in results[&#39;logits&#39;] if l &gt; -10000], bins=&#39;auto&#39;)
    axes[0].set_xlabel(&#39;Logits&#39;)
    axes[0].set_ylabel(&#39;Frequency&#39;)

    # performance degradation
    axes[1].title.set_text(&#39;Performance degradation&#39;)
    x, y = pd.DataFrame([results[&#39;R_n_star&#39;], results[&#39;R_bar_n_star&#39;]]).dropna(axis=1).values
    sns.regplot(x, y, ax=axes[1])
    #axes[1].set_xlim(min(results[&#39;R_n_star&#39;]) * 1.2,max(results[&#39;R_n_star&#39;]) * 1.2)
    #axes[1].set_ylim(min(results[&#39;R_bar_n_star&#39;]) * 1.2,max(results[&#39;R_bar_n_star&#39;]) * 1.2)
    axes[1].set_xlabel(&#39;In-sample Performance&#39;)
    axes[1].set_ylabel(&#39;Out-of-sample Performance&#39;)

    # first and second Stochastic dominance
    axes[2].title.set_text(&#39;Stochastic dominance&#39;)
    if len(results[&#39;dom_df&#39;]) != 0: results[&#39;dom_df&#39;].plot(ax=axes[2], secondary_y=[&#39;SD2&#39;])
    axes[2].set_xlabel(&#39;Performance optimized vs non-optimized&#39;)
    axes[2].set_ylabel(&#39;Frequency&#39;)


def variable_visualization(portfolio):

    param_names = portfolio.cumulative_returns().columns.names
    dropdown1 = widgets.Dropdown(
        options=param_names,
        value=param_names[0],
        description=&#39;axis 1:&#39;,
        disabled=False,
    )
    dropdown2 = widgets.Dropdown(
        options=param_names,
        value=param_names[0],
        description=&#39;axis 2:&#39;,
        disabled=False,
    )

    performance_metric = [&#39;final_value&#39;,
        &#39;calmar_ratio&#39;, &#39;max_drawdown&#39;, &#39;sharpe_ratio&#39;,
        &#39;downside_risk&#39;, &#39;omega_ratio&#39;, &#39;conditional_value_at_risk&#39;]

    performance_dropdwon = widgets.Dropdown(
        options=performance_metric,
        value=performance_metric[0],
        description=&#39;performance&#39;,
        disabled=False,
    )

    out = widgets.Output()

    import matplotlib.pyplot as plt
    def update(v):
        name1 = dropdown1.value
        name2 = dropdown2.value
        performance = performance_dropdwon.value

        with out:
            out.clear_output()
            if name1 != name2:
                df = (getattr(portfolio, performance)()
                      .reset_index().groupby([name1, name2]).mean()[0]
                      .reset_index().pivot(name1, name2)[0])

                df = df.replace([np.inf, -np.inf], np.nan)
                sns.heatmap(df)
            else:
                getattr(portfolio, performance)().groupby(name1).mean().plot()
            plt.show()


    dropdown1.observe(update, &#39;value&#39;)
    dropdown2.observe(update, &#39;value&#39;)
    performance_dropdwon.observe(update, &#39;value&#39;)
    drawdowns = widgets.VBox([performance_dropdwon,
                 widgets.HBox([dropdown1, dropdown2])])
    display(drawdowns)
    display(out)
    update(0)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="finlab_crypto.utility.enumerate_signal"><code class="name flex">
<span>def <span class="ident">enumerate_signal</span></span>(<span>ohlcv, strategy, variables)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def enumerate_signal(ohlcv, strategy, variables, ):
    entries = {}
    exits = {}

    fig = {}

    iteration = tqdm.tqdm(variables) if len(variables) &gt; 1 else variables
    for v in iteration:
        strategy.set_parameters(v)
        results = strategy.func(ohlcv)

        v = remove_pd_object(v)

        entries[str(v)], exits[str(v)] = results[0], results[1]
        if len(results) &gt;= 3:
            fig = results[2]

    entries = pd.DataFrame(entries)
    exits = pd.DataFrame(exits)

    # setup columns
    param_names = list(eval(entries.columns[0]).keys())
    arrays = ([entries.columns.map(lambda s: eval(s)[p]) for p in param_names])
    tuples = list(zip(*arrays))
    if tuples:
        columns = pd.MultiIndex.from_tuples(tuples, names=param_names)
        exits.columns = columns
        entries.columns = columns
    return entries, exits, fig</code></pre>
</details>
</dd>
<dt id="finlab_crypto.utility.enumerate_variables"><code class="name flex">
<span>def <span class="ident">enumerate_variables</span></span>(<span>variables)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def enumerate_variables(variables):

    if not variables:
        return []

    enumeration_name = []
    enumeration_vars = []

    constant_d = {}

    for name, v in variables.items():
        if (isinstance(v, Iterable) and not isinstance(v, str)
            and not isinstance(v, pd.Series)
            and not isinstance(v, pd.DataFrame)):

            enumeration_name.append(name)
            enumeration_vars.append(v)
        else:
            constant_d[name] = v

    variable_enumerations = [dict(**dict(zip(enumeration_name, ps)), **constant_d)
                             for ps in list(product(*enumeration_vars))]

    return variable_enumerations</code></pre>
</details>
</dd>
<dt id="finlab_crypto.utility.is_evalable"><code class="name flex">
<span>def <span class="ident">is_evalable</span></span>(<span>obj)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_evalable(obj):
    try:
        eval(str(obj))
        return True
    except:
        return False</code></pre>
</details>
</dd>
<dt id="finlab_crypto.utility.plot_combination"><code class="name flex">
<span>def <span class="ident">plot_combination</span></span>(<span>portfolio, cscv_result=None, metric='final_value')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_combination(portfolio, cscv_result=None, metric=&#39;final_value&#39;):

    sns.set()
    sns.set_style(&#34;whitegrid&#34;)

    fig, axes = plt.subplots(1, 2, figsize=(15, 4), sharey=False, sharex=False)
    fig.suptitle(&#39;Backtest Results&#39;)

    def heat_map(item, name1, name2, ax):
        if name1 != name2:
            sns.heatmap(item.reset_index().pivot(name1, name2)[0], cmap=&#39;magma_r&#39;, ax=ax)
        else:
            getattr(portfolio, item_name).groupby(name1).mean().plot(ax=ax)

    def best_n(portfolio, n):
        return getattr(portfolio, metric)().sort_values().tail(n).index

    best_10 = best_n(portfolio, 10)

    ax = (portfolio.cumulative_returns()[best_10] * 100).plot(ax=axes[0])
    ax.set(xlabel=&#39;time&#39;, ylabel=&#39;cumulative return (%)&#39;)

    axes[1].title.set_text(&#39;Drawdown (%)&#39;)
    for n, c in zip([5, 10, 20, 30], sns.color_palette(&#34;GnBu_d&#34;)):
        bests = best_n(portfolio, n)
        drawdown = portfolio.drawdown()[bests].min(axis=1)
        ax = drawdown.plot(linewidth=1, ax=axes[1])
        # ax.fill_between(drawdown.index, 0, drawdown * 100, alpha=0.2, color=c)
    ax.set(xlabel=&#39;time&#39;, ylabel=&#39;drawdown (%)&#39;)

    plt.show()


    items = [&#39;final_value&#39;, &#39;sharpe_ratio&#39;, &#39;sortino_ratio&#39;]
    fig, axes = plt.subplots(1, len(items), figsize=(15, 3),
                             sharey=False, sharex=False, constrained_layout=False)
    fig.subplots_adjust(top=0.75)
    fig.suptitle(&#39;Partial Differentiation&#39;)

    final_value = portfolio.final_value()
    if isinstance(final_value.index, pd.MultiIndex):
        index_names = final_value.index.names
    else:
        index_names = [final_value.index.name]

    for i, item in enumerate(items):
        results = {}
        for name in index_names:
            s = getattr(portfolio, item)()
            s = s.replace([np.inf, -np.inf], np.nan)
            results[name] = s.groupby(name).mean()
        results = pd.DataFrame(results)
        axes[i].title.set_text(item)
        results.plot(ax=axes[i])

    if cscv_result is None:
        return

    results = cscv_result

    fig, axes = plt.subplots(1, 3, figsize=(15, 5),
                             sharey=False, sharex=False, constrained_layout=False)
    fig.subplots_adjust(bottom=0.5)
    fig.suptitle(&#39;Combinatorially Symmetric Cross-validation&#39;)

    pbo_test = round(results[&#39;pbo_test&#39;] * 100, 2)
    axes[0].title.set_text(f&#39;Probability of overfitting: {pbo_test} %&#39;)
    axes[0].hist(x=[l for l in results[&#39;logits&#39;] if l &gt; -10000], bins=&#39;auto&#39;)
    axes[0].set_xlabel(&#39;Logits&#39;)
    axes[0].set_ylabel(&#39;Frequency&#39;)

    # performance degradation
    axes[1].title.set_text(&#39;Performance degradation&#39;)
    x, y = pd.DataFrame([results[&#39;R_n_star&#39;], results[&#39;R_bar_n_star&#39;]]).dropna(axis=1).values
    sns.regplot(x, y, ax=axes[1])
    #axes[1].set_xlim(min(results[&#39;R_n_star&#39;]) * 1.2,max(results[&#39;R_n_star&#39;]) * 1.2)
    #axes[1].set_ylim(min(results[&#39;R_bar_n_star&#39;]) * 1.2,max(results[&#39;R_bar_n_star&#39;]) * 1.2)
    axes[1].set_xlabel(&#39;In-sample Performance&#39;)
    axes[1].set_ylabel(&#39;Out-of-sample Performance&#39;)

    # first and second Stochastic dominance
    axes[2].title.set_text(&#39;Stochastic dominance&#39;)
    if len(results[&#39;dom_df&#39;]) != 0: results[&#39;dom_df&#39;].plot(ax=axes[2], secondary_y=[&#39;SD2&#39;])
    axes[2].set_xlabel(&#39;Performance optimized vs non-optimized&#39;)
    axes[2].set_ylabel(&#39;Frequency&#39;)</code></pre>
</details>
</dd>
<dt id="finlab_crypto.utility.plot_strategy"><code class="name flex">
<span>def <span class="ident">plot_strategy</span></span>(<span>ohlcv, entries, exits, portfolio, fig_data, html=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_strategy(ohlcv, entries, exits, portfolio ,fig_data, html=None):

    # format trade data
    txn = portfolio.positions().records
    txn[&#39;enter_time&#39;] = ohlcv.iloc[txn.entry_idx].index.values
    txn[&#39;exit_time&#39;] = ohlcv.iloc[txn.exit_idx].index.values

    # plot trade data
    mark_lines = []
    for name, t in txn.iterrows():
        x = [str(t.enter_time), str(t.exit_time)]
        y = [t.entry_price, t.exit_price]
        name = t.loc[[&#39;entry_price&#39;, &#39;exit_price&#39;, &#39;return&#39;]].to_string()
        mark_lines.append((name, x, y))

    # calculate overlap figures
    overlaps = {}
    if &#39;overlaps&#39; in fig_data:
        overlaps = fig_data[&#39;overlaps&#39;]

    # calculate sub-figures
    figures = {}
    if &#39;figures&#39; in fig_data:
        figures = fig_data[&#39;figures&#39;]

    figures[&#39;entries &amp; exits&#39;] = pd.DataFrame(
        {&#39;entries&#39;:entries.squeeze(), &#39;exits&#39;: exits.squeeze()})
    figures[&#39;performance&#39;] = portfolio.cumulative_returns()

    c, info = chart.chart(ohlcv, overlaps=overlaps,
                          figures=figures, markerlines=mark_lines,
                          start_date=ohlcv.index[-min(1000, len(ohlcv))], end_date=ohlcv.index[-1])
    c.load_javascript()
    if html is not None:          
        c.render(html)
    else:
        c.render()
        display(HTML(filename=&#39;render.html&#39;))

    return </code></pre>
</details>
</dd>
<dt id="finlab_crypto.utility.remove_pd_object"><code class="name flex">
<span>def <span class="ident">remove_pd_object</span></span>(<span>d)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_pd_object(d):
    ret = {}
    for n, v in d.items():
        if ((not isinstance(v, pd.Series) and not isinstance(v, pd.DataFrame) and not callable(v) and is_evalable(v))
            or isinstance(v, str)):
            ret[n] = v
    return ret</code></pre>
</details>
</dd>
<dt id="finlab_crypto.utility.stop_early"><code class="name flex">
<span>def <span class="ident">stop_early</span></span>(<span>ohlcv, entries, exits, stop_vars, enumeration=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stop_early(ohlcv, entries, exits, stop_vars, enumeration=True):

    if not stop_vars:
        return entries, exits

    # check for stop_vars
    length = -1
    stop_vars_set = {&#39;sl_stop&#39;, &#39;ts_stop&#39;, &#39;tp_stop&#39;}
    for s, slist in stop_vars.items():
        if s not in stop_vars_set:
            raise Exception(f&#39;variable { s } is not one of the stop variables&#39;
                             &#39;: sl_stop, ts_stop, or tp_stop&#39;)
        if not isinstance(slist, Iterable):
            stop_vars[s] = [slist]

        if length == -1:
            length = len(stop_vars[s])

        if not enumeration and length != -1 and length != len(stop_vars[s]):
            raise Exception(f&#39;lengths of the variables are not align: &#39;
                    + str([len(stop_vars[s]) for s, slist in stop_vars.items()]))

    if enumeration:
        stop_vars = enumerate_variables(stop_vars)
        stop_vars = {key: [stop_vars[i][key] for i in range(len(stop_vars))] for key in stop_vars[0].keys()}

    sl_advstex = vbt.ADVSTEX.run(
        entries,
        ohlcv[&#39;open&#39;],
        ohlcv[&#39;high&#39;],
        ohlcv[&#39;low&#39;],
        ohlcv[&#39;close&#39;],
        stop_type=None,
        **stop_vars
    )

    stop_exits = sl_advstex.exits

    nrepeat = int(len(stop_exits.columns) / len(entries.columns))
    if isinstance(stop_exits, pd.DataFrame):
        exits = exits.vbt.tile(nrepeat)
        entries = entries.vbt.tile(nrepeat)

    stop_exits = stop_exits.vbt | exits.values
    entries.columns = stop_exits.columns

    return entries, stop_exits</code></pre>
</details>
</dd>
<dt id="finlab_crypto.utility.variable_visualization"><code class="name flex">
<span>def <span class="ident">variable_visualization</span></span>(<span>portfolio)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def variable_visualization(portfolio):

    param_names = portfolio.cumulative_returns().columns.names
    dropdown1 = widgets.Dropdown(
        options=param_names,
        value=param_names[0],
        description=&#39;axis 1:&#39;,
        disabled=False,
    )
    dropdown2 = widgets.Dropdown(
        options=param_names,
        value=param_names[0],
        description=&#39;axis 2:&#39;,
        disabled=False,
    )

    performance_metric = [&#39;final_value&#39;,
        &#39;calmar_ratio&#39;, &#39;max_drawdown&#39;, &#39;sharpe_ratio&#39;,
        &#39;downside_risk&#39;, &#39;omega_ratio&#39;, &#39;conditional_value_at_risk&#39;]

    performance_dropdwon = widgets.Dropdown(
        options=performance_metric,
        value=performance_metric[0],
        description=&#39;performance&#39;,
        disabled=False,
    )

    out = widgets.Output()

    import matplotlib.pyplot as plt
    def update(v):
        name1 = dropdown1.value
        name2 = dropdown2.value
        performance = performance_dropdwon.value

        with out:
            out.clear_output()
            if name1 != name2:
                df = (getattr(portfolio, performance)()
                      .reset_index().groupby([name1, name2]).mean()[0]
                      .reset_index().pivot(name1, name2)[0])

                df = df.replace([np.inf, -np.inf], np.nan)
                sns.heatmap(df)
            else:
                getattr(portfolio, performance)().groupby(name1).mean().plot()
            plt.show()


    dropdown1.observe(update, &#39;value&#39;)
    dropdown2.observe(update, &#39;value&#39;)
    performance_dropdwon.observe(update, &#39;value&#39;)
    drawdowns = widgets.VBox([performance_dropdwon,
                 widgets.HBox([dropdown1, dropdown2])])
    display(drawdowns)
    display(out)
    update(0)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="finlab_crypto" href="index.html">finlab_crypto</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="finlab_crypto.utility.enumerate_signal" href="#finlab_crypto.utility.enumerate_signal">enumerate_signal</a></code></li>
<li><code><a title="finlab_crypto.utility.enumerate_variables" href="#finlab_crypto.utility.enumerate_variables">enumerate_variables</a></code></li>
<li><code><a title="finlab_crypto.utility.is_evalable" href="#finlab_crypto.utility.is_evalable">is_evalable</a></code></li>
<li><code><a title="finlab_crypto.utility.plot_combination" href="#finlab_crypto.utility.plot_combination">plot_combination</a></code></li>
<li><code><a title="finlab_crypto.utility.plot_strategy" href="#finlab_crypto.utility.plot_strategy">plot_strategy</a></code></li>
<li><code><a title="finlab_crypto.utility.remove_pd_object" href="#finlab_crypto.utility.remove_pd_object">remove_pd_object</a></code></li>
<li><code><a title="finlab_crypto.utility.stop_early" href="#finlab_crypto.utility.stop_early">stop_early</a></code></li>
<li><code><a title="finlab_crypto.utility.variable_visualization" href="#finlab_crypto.utility.variable_visualization">variable_visualization</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>